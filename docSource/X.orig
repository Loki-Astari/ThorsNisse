<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>API Reference</title>

<link href="images/favicon.ico" rel="icon" type="image/ico" />
<link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
<link href="stylesheets/print.css" rel="stylesheet" media="print" />
<script src="javascripts/all_nosearch.js"></script>
</head>
<body class="index" data-languages="[]">
<a href="#" id="nav-button">
<span>
NAV
<img src="images/navbar.png" alt="Navbar" />
</span>
</a>
<div class="toc-wrapper">
<img src="images/logo.png" class="logo" alt="Logo" />
<div id="toc" class="toc-list-h1">
<li>
<a href="#introduction" class="toc-h1 toc-link" data-title="Introduction">Introduction</a>
</li>
<li>
<a href="#node-cxx" class="toc-h1 toc-link" data-title="Node.Cxx">Node.Cxx</a>
</li>
<li>
<a href="#express" class="toc-h1 toc-link" data-title="Express">Express</a>
</li>
<li>
<a href="#core" class="toc-h1 toc-link" data-title="Core">Core</a>
<ul class="toc-list-h2">
<li>
<a href="#utility" class="toc-h2 toc-link" data-title="Core">Utility</a>
</li>
<li>
<a href="#socket" class="toc-h2 toc-link" data-title="Core">Socket</a>
<ul class="toc-list-h3">
<li>
<a href="#basesocket" class="toc-h3 toc-link" data-title="Core">BaseSocket</a>
</li>
<li>
<a href="#datasocket" class="toc-h3 toc-link" data-title="Core">DataSocket</a>
</li>
<li>
<a href="#connectionsocket" class="toc-h3 toc-link" data-title="Core">ConnectionSocket</a>
</li>
<li>
<a href="#serversocket" class="toc-h3 toc-link" data-title="Core">ServerSocket</a>
</li>
<li>
<a href="#socketstreambuffer" class="toc-h3 toc-link" data-title="Core">SocketStreamBuffer</a>
</li>
<li>
<a href="#isocketstream" class="toc-h3 toc-link" data-title="Core">ISocketStream</a>
</li>
<li>
<a href="#osocketstream" class="toc-h3 toc-link" data-title="Core">OSocketStream</a>
</li>
</ul>
</li>
<li>
<a href="#service" class="toc-h2 toc-link" data-title="Core">Service</a>
<ul class="toc-list-h3">
<li>
<a href="#handlerbase" class="toc-h3 toc-link" data-title="Core">HandlerBase</a>
</li>
<li>
<a href="#handlerstream" class="toc-h3 toc-link" data-title="Core">HandlerStream</a>
</li>
<li>
<a href="#handlernonsuspendable" class="toc-h3 toc-link" data-title="Core">HandlerNonSuspendable</a>
</li>
<li>
<a href="#handlersuspendable" class="toc-h3 toc-link" data-title="Core">HandlerSuspendable</a>
</li>
<li>
<a href="#handlersuspendablewithstream" class="toc-h3 toc-link" data-title="Core">HandlerSuspendableWithStream</a>
</li>
<li>
<a href="#serverconnection" class="toc-h3 toc-link" data-title="Core">ServerConnection</a>
</li>
<li>
<a href="#server" class="toc-h3 toc-link" data-title="Core">Server</a>
</li>
<li>
<a href="#serverhandler" class="toc-h3 toc-link" data-title="Core">ServerHandler</a>
</li>
<li>
<a href="#timerhandler" class="toc-h3 toc-link" data-title="Core">TimerHandler</a>
</li>
</ul>
</li>
<li>
<a href="#sql" class="toc-h2 toc-link" data-title="Core">SQL</a>
</li>
</ul>
</li>
<li>
<a href="#protocol" class="toc-h1 toc-link" data-title="Protocol">Protocol</a>
<ul class="toc-list-h2">
<li>
<a href="#simple" class="toc-h2 toc-link" data-title="Protocol">Simple</a>
</li>
<li>
<a href="#http" class="toc-h2 toc-link" data-title="Protocol">HTTP</a>
</li>
</ul>
</li>
<li>
<a href="#examples" class="toc-h1 toc-link" data-title="Examples">Examples</a>
<ul class="toc-list-h2">
<li>
<a href="#addbeer" class="toc-h2 toc-link" data-title="Examples">AddBeer</a>
</li>
</ul>
</li>
</div>
<ul class="toc-footer">
<li><a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
</ul>
</div>
<div class="page-wrapper">
<div class="dark-box"></div>
<div class="content">
<h1 id='introduction'>Introduction</h1>
<p><a href="https://github.com/Loki-Astari/ThorsNisse">ThorsNisse</a> is RESTful server framework for C++.<br>
It is based on Node.js and its family of associated packages. ThorsNisse uses transparently non-blocking <code>std::streams</code> to achieve high throughput and low complexity of development on a single threaded server.</p>
<p>What does <strong>transparently non-blocking:</strong> mean?</p>
<ul>
<li>To the user of the std::stream it will appear to be standard blocking stream; thus allowing very normal looking C++ code to be written.</li>
<li>To make the framework efficient any blocking read/write calls transfers control back to the Nisse Framework so that other streams may be processed.</li>
</ul>
<h1 id='node-cxx'>Node.Cxx</h1>
<p>To simplify development for those that simply want to write HTTP RESTful endpoints the server Node.Cxx is provided to handle all the boilerplate.</p>
<p>Node.Cxx (Lovingly named after Node.js for the inspiration) is a simple HTTP server implemented using the ThorsNisse framework that will dynamically load <a href="#express">Express</a> modules.</p>
<p>The Node.Cxx server takes two flags as arguments on startup:</p>
<pre class="highlight shell"><code> &gt; Node.cxx <span class="o">[</span>--debug:&lt;port&gt;] <span class="o">[</span>--load:&lt;SharedLib&gt;:&lt;Host&gt;:&lt;Base&gt;:&lt;port&gt;]
<span class="c">#</span>
<span class="c"># --debug:8081</span>
<span class="c">#      Loads the dynamic loader so it listens on port 8081</span>
<span class="c">#          To load a libray:</span>
<span class="c">#              curl --data '{"action": "Load",   "host": "test.com", "base": "", "port": 8080, "lib": "AddBeer.dylib"}' localhost:8081</span>
<span class="c">#          To unload a library:</span>
<span class="c">#              curl --data '{"action": "Unload", "host": "test.com", "base": "", "port": 8080}'  localhost:8081</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c"># --load:AddBeer.dylib:test.com::8080</span>
<span class="c">#      Loads the AddBeer.dylib express module.</span>
<span class="c">#          And binds it to the root of http://test.com</span>
<span class="c">#</span>
<span class="c">#          Assume AddBeer defines the end pointes /AddBeer</span>
<span class="c">#          When a request to `http://test.com/AddBeer the associated code will be called.</span>
<span class="c">#</span>
<span class="c"># --load:AddDrink.dylib:test.com:/drinks:8080</span>
<span class="c">#      Loads the AddDrink.dylib express module.</span>
<span class="c">#          And binds it to http://test.com/drinks</span>
<span class="c">#</span>
<span class="c">#          Assume AddDrink defines the end pointes /AddDrink</span>
<span class="c">#          When a request to `http://test.com/drinks/AddDrink the associated code will be called.</span>
<span class="c">#</span>
<span class="c">#          Note we did not bind AddDrink to the root of test.com so you need to add the `Base` to</span>
<span class="c">#          all routes defined by the library in its code.</span>
</code></pre>
<table><thead>
<tr>
<th>Command Line Flag</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>--debug</td>
<td>Installs the dynamic library loader.<br>This allows shared libraries to be loaded/unloaded at runtime without restarting the server. Useful for building and debugging but should not be used in production.<br><br>As the command to load/unload library is simply a REST call to the specified port; this can be included into your build environment to un-install the old version and install the newly build version allowing a quick turn around for development.</td>
</tr>
<tr>
<td>--load</td>
<td>Loads a shared library that is linked with <a href="#express">Express</a>.<br>This flag can be used multiple times.<br><br>The express module provides the facility to easily associate code with REST end points.<br><br>This flag uses the same underlying code as the REST call to load a site. So these sites can also be dynamically unloaded if required.</td>
</tr>
</tbody></table>
<h1 id='express'>Express</h1><pre class="highlight cpp tab-cpp"><code><span class="c1">// Must include this header
</span><span class="cp">#include "ThorsExpress/all.h"
</span>
<span class="k">namespace</span> <span class="n">HTTP</span> <span class="o">=</span> <span class="n">ThorsAnvil</span><span class="o">::</span><span class="n">Nisse</span><span class="o">::</span><span class="n">Protocol</span><span class="o">::</span><span class="n">HTTP</span><span class="p">;</span>
<span class="c1">// Must define this function once.
</span><span class="kt">void</span> <span class="nf">addSite</span><span class="p">(</span><span class="n">HTTP</span><span class="o">::</span><span class="n">Site</span><span class="o">&amp;</span> <span class="n">site</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">site</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/listBeer"</span><span class="p">,</span> <span class="p">[](</span><span class="n">HTTP</span><span class="o">::</span><span class="n">Request</span><span class="o">&amp;</span> <span class="n">request</span><span class="p">,</span> <span class="n">HTTP</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">response</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">});</span>
<span class="c1">// You can add as many resources to as site as you need.
</span><span class="p">}</span>
</code></pre>
<p>Express is a simple library that allows the definition of simple HTTP site modules that can be loaded/unload dynamically. Though each site object is simple each one can be bound to a different relative paths on a site.</p>
<h1 id='core'>Core</h1><h2 id='utility'>Utility</h2><pre class="highlight cpp tab-cpp"><code><span class="k">if</span> <span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="s">"file"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span>
<span class="n">buildErrorMessage</span><span class="p">(</span><span class="s">"MyClass::"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
<span class="s">": open: "</span><span class="p">,</span> <span class="n">Utility</span><span class="o">::</span><span class="n">systemErrorMessage</span><span class="p">()));</span>
<span class="p">}</span>
</code></pre><pre class="highlight cpp tab-cpp--DeepDive"><code><span class="c1">// Utility.h
</span><span class="cm">/*
* Builds a string for a system error message.
* uses `errno` to build the name of the error and the associated message into a string.
*/</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">systemErrorMessage</span><span class="p">();</span>
<span class="cm">/*
* Build an error message from a set of parameters.
* Slightly more compact than using 'operator&lt;&lt;` very useful for building exception messages.
*/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buildErrorMessage</span><span class="p">(</span><span class="n">Args</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre>
<p>Provides common utility functions for other packages.
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::Utility</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreUtility/</dd>
<dt>Utility.h</dt><dd></p>
<ul>
<li>std::string systemErrorMessage();</li>
<li>std::string buildErrorMessage();</li>
</ul>
<p></dd>
</dl></p>
<h2 id='socket'>Socket</h2><pre class="highlight shell"><code> &gt; g++ Socket.cpp -o Socket -I<span class="k">${</span><span class="nv">THOR_ROOT</span><span class="k">}</span>/include -L<span class="k">${</span><span class="nv">THOR_ROOT</span><span class="k">}</span>/lib -lThorsExpress17
&gt; curl --data <span class="s2">"A test message in a bottle :)"</span> http://localhost:8080;echo
</code></pre><pre class="highlight cpp tab-cpp"><code><span class="c1">// Server Side
</span><span class="cp">#include "ThorsNisseCoreSocket/Socket.h"
#include "ThorsNisseCoreSocket/SocketStream.h"
#include &lt;string&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">Sock</span> <span class="o">=</span> <span class="n">ThorsAnvil</span><span class="o">::</span><span class="n">Nisse</span><span class="o">::</span><span class="n">Core</span><span class="o">::</span><span class="n">Socket</span><span class="p">;</span>
<span class="n">Sock</span><span class="o">::</span><span class="n">ServerSocket</span>    <span class="n">server</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Sock</span><span class="o">::</span><span class="n">DataSocket</span>    <span class="n">connection</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
<span class="n">Sock</span><span class="o">::</span><span class="n">ISocketStream</span> <span class="n">input</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">request</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">header</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>     <span class="n">bodySize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">header</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*
* Note: This code is still handling the intricacy of the HTTP protocol
*       so it is brittle. See Protocol/HTTP for help with handling the
*       details of the protocol.
*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s">"Content-Length:"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="n">bodySize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">message</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">line</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">bodySize</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
<span class="p">{</span>
<span class="n">message</span> <span class="o">+=</span> <span class="n">line</span><span class="p">;</span>
<span class="n">message</span> <span class="o">+=</span> <span class="s">"&lt;br&gt;"</span><span class="p">;</span>
<span class="n">bodySize</span> <span class="o">-=</span> <span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Sock</span><span class="o">::</span><span class="n">OSocketStream</span> <span class="n">output</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
<span class="cm">/*
* Note: This code is still handling the intricacy of the HTTP protocol
*       so it is brittle. See Protocol/HTTP for help with handling the
*       details of the protocol.
*/</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"Content-Length: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">11</span> <span class="o">+</span> <span class="n">message</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"It Worked: "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A simple wrapper around BSD sockets so they are easy to use in C++.
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::Socket</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreSocket/</dd>
<dt>Socket.h</dt><dd></p>
<ul>
<li>class BaseSocket</li>
<li>class DataSocket: public BaseSocket</li>
<li>class ConnectionSocket: public DataSocket</li>
<li>class ServerSocket: public BaseSocket</li>
</ul>
<p></dd>
<dt>SocketStream.h</dt><dd></p>
<ul>
<li>class SocketStreamBuffer: public std::streambuf</li>
<li>class ISocketStream: public std::istream</li>
<li>class OSocketStream: public std::ostream</li>
</ul>
<p></dd>
</dl></p>
<h3 id='basesocket'>BaseSocket</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">BaseSocket</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">Base of all the socket classes.<br>
This class should not be directly created.<br>
All socket classes are movable but not copyable.</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">BaseSocket(BaseSocket&&)</div><div class="methodMark">noexcept</div></div>
<div class="classRow"><div class="methodRet">BaseSocket&</div><div class="methodName">operator=(BaseSocket&&)</div><div class="methodMark">noexcept</div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">swap(BaseSocket&)</div><div class="methodMark">noexcept</div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">close()</div><div class="methodMark"></div></div>
</div>
</div>
</div>
<h3 id='datasocket'>DataSocket</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">DataSocket</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">BaseSocket</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
Data sockets define the read/write interface to a socket.<br>
This class should not be directly created
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">std::pair&lt;bool, std::size_t&gt;</div><div class="methodName">getMessageData(char* buffer, std::size_t size, std::size_t alreadyGot = 0)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">std::pair&lt;bool, std::size_t&gt;</div><div class="methodName">putMessageData(char const* buffer, std::size_t size, std::size_t alreadyPut = 0)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">putMessageClose()</div><div class="methodMark"></div></div>
</div>
</div>
</div>
<h4 id='datasocket-getmessagedata'>DataSocket::getMessageData</h4>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">getMessageData()</div></div>
<div class="classRow"><div class="classDesc">
Reads data from a sokcet into a buffer.<br>
If the stream is blocking will not return until the requested amount of data has been read or there is no more data to read.<br>
If the stream in non blocking will return if the read operation would block.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Return Value</div></div>
<div class="classRow"><div class="classDesc">
This method returns a pair: <code>std::pair&lt;bool, std::size_t&gt;</code><br>
The first member `bool` indicates if more data can potentially be read from the stream. If the socket was cut or the EOF reached then this value will be false<br>
The second member `std::size_t` indicates exactly how many bytes were read from this stream.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">buffer</div><div class="classValue">The buffer data will be read into.</div></div>
<div class="classRow"><div class="classItem">size</div><div class="classValue">The size of the buffer.</div></div>
<div class="classRow"><div class="classItem">alreadyGot</div><div class="classValue">Offset into buffer (and amount size is reduced by) as this amount was read on a previous call).</div></div>
</div>
</div>
</div>
<h4 id='datasocket-putmessagedata'>DataSocket::putMessageData</h4>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">putMessageData()</div></div>
<div class="classRow"><div class="classDesc">
Writes data from a buffer to a sokcet.<br>
If the stream is blocking will not return until the requested amount of data has been written or the socket was closed to writting.<br>
If the stream in non blocking will return if the write operation would block.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Return Value</div></div>
<div class="classRow"><div class="classDesc">
This method returns a pair: <code>std::pair&lt;bool, std::size_t&gt;</code><br>
The first member `bool` indicates if more data can potentially be written to the stream. If the socket was cut or closed then this value will be false<br>
The second member `std::size_t` indicates exactly how many bytes were written to this stream.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">buffer</div><div class="classValue">The buffer data will be written from.</div></div>
<div class="classRow"><div class="classItem">size</div><div class="classValue">The size of the buffer.</div></div>
<div class="classRow"><div class="classItem">alreadyPut</div><div class="classValue">Offset into buffer (and amount size is reduced by) as this amount was written on a previous call).</div></div>
</div>
</div>
</div>
<h4 id='datasocket-putmessageclose'>DataSocket::putMessageClose</h4>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">putMessageClose()</div></div>
<div class="classRow"><div class="classDesc">
closes the write end of the socket and flushes (write) data.
</div></div>
</div>
</div>
</div>
<h3 id='connectionsocket'>ConnectionSocket</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ConnectionSocket</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">DataSocket</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
Creates a connection to <code>host</code> on <code>port</code>.<br>
Note this class inherits from <code>DataSocket</code> so once created you can read/write to the socket.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">ConnectionSocket(std::string const& host, int port)</div><div class="methodMark"></div></div>
</div>
</div>
</div>
<h3 id='serversocket'>ServerSocket</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ServerSocket</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">BaseSocket</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">ServerSocket(int port, bool blocking, int maxWaitConnections = ServerSocket::maxConnectionBacklog)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">DataSocket</div><div class="methodName">accept(bool blocking)</div><div class="methodMark"></div></div>
</div>
</div>
</div>
<h4 id='serversocket-accept'>ServerSocket::accept</h4>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">accept()</div></div>
<div class="classRow"><div class="classDesc">
"Accept" a waiting connection request on the port and creates a two way socket for communication on another port.<br>
If this is a non blocking socket and there is no waiting connection an exception is thrown.<br>
If this is a blocking socket wait for a connection<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Return Value</div></div>
<div class="classRow"><div class="classDesc">
A <code>DataSocket</code> is returned so data can be exchange across the socket.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">blocking</div><div class="classValue">Passed to the constructor of the <code>DataSocket</code> that is returned.</div></div>
</div>
</div>
</div>
<h3 id='socketstreambuffer'>SocketStreamBuffer</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/SocketStream.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">SocketStreamBuffer</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">std::streambug</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
This is a wrapper class for a <code>DataSocket</code> that allows the socket to be treated like <code>std::streambuf</code>.<br>
This class overrides just enough virtual functions to make the <code>ISocketStream</code> and <code>OSocketStream</code> useful.<br>
This class provides no public API and is designed to be used solely with the following stream objects.
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
</div>
</div>
<h3 id='isocketstream'>ISocketStream</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/SocketStream.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ISocketStream</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">std::istream</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
An implementation of <code>std::istream</code> that uses <code>SocketStreamBuffer</code> as the buffer.<br>
The <code>Notofer</code> is a primitive event callback mechanism.<br>
A blocking read call to these streams calls the <code>Notifier noData</code>. This is used by the <a href="#Server">Server</a> infastructure to yield control back to the main event loop.<br>
<code>using Notifier = std::function<void()>;</code>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">ISocketStream(DataSocket& stream, Notifier noData, Notfier flush)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet"></div><div class="methodName">ISocketStream(DataSocket& stream)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet"></div><div class="methodName">ISocketStream(ISocketStream&& move)</div><div class="methodMark"></div></div>
</div>
</div>
</div>
<h3 id='osocketstream'>OSocketStream</h3>
<div class="classTable">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/SocketStream.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
<div class="classRow"><div class="classItem">Class:    </div><div class="classValue">OSocketStream</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">std::istream</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
An implementation of <code>std::ostream</code> that uses <code>SocketStreamBuffer</code> as the buffer.<br>
The <code>Notofer</code> is a primitive event callback mechanism.
A blocking write call to these streams calls the <code>Notifier noData</code>. This is used by the <a href="#Server">Server</a> infastructure to yield control back to the main event loop.<br>
<code>using Notifier = std::function<void()>;</code>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Members:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">OSocketStream(DataSocket& stream, Notifier noData, Notfier flush)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet"></div><div class="methodName">OSocketStream(DataSocket& stream)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet"></div><div class="methodName">OSocketStream(OSocketStream&& move)</div><div class="methodMark"></div></div>
</div>
</div>
</div>
<h2 id='service'>Service</h2><pre class="highlight shell"><code> &gt; g++ -std<span class="o">=</span>c++1z Server.cpp -o Server -I<span class="k">${</span><span class="nv">THOR_ROOT</span><span class="k">}</span>/include -L<span class="k">${</span><span class="nv">THOR_ROOT</span><span class="k">}</span>/lib -lThorsExpress17 -lboost_context-mt
&gt; curl --data <span class="s2">"A test message in a bottle :)"</span> http://localhost:8080;echo
</code></pre><pre class="highlight cpp tab-cpp"><code><span class="cp">#include "ThorsNisseCoreService/Server.h"
#include "ThorsNisseCoreService/Handler.h"
#include "ThorsNisseCoreSocket/Socket.h"
#include "ThorsNisseCoreSocket/SocketStream.h"
#include &lt;string&gt;
</span><span class="k">namespace</span> <span class="n">Serv</span> <span class="o">=</span> <span class="n">ThorsAnvil</span><span class="o">::</span><span class="n">Nisse</span><span class="o">::</span><span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">Sock</span> <span class="o">=</span> <span class="n">ThorsAnvil</span><span class="o">::</span><span class="n">Nisse</span><span class="o">::</span><span class="n">Core</span><span class="o">::</span><span class="n">Socket</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MyHandler</span><span class="o">:</span> <span class="k">public</span> <span class="n">Serv</span><span class="o">::</span><span class="n">HandlerSuspendableWithStream</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">MyHandler</span><span class="p">(</span><span class="n">Serv</span><span class="o">::</span><span class="n">Server</span><span class="o">&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Sock</span><span class="o">::</span><span class="n">DataSocket</span><span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="p">)</span>
<span class="o">:</span> <span class="n">HandlerSuspendableWithStream</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span> <span class="n">EV_READ</span><span class="p">)</span>
<span class="p">{}</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">eventActivateWithStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*
* Note: The streams `input` and `output` are transparently non-blocking.
*       Any blocking read/write will transfer control back to the server
*       event loop.
*
* To the code in this function any read/write requests appear to be blocking
* So the writting code is still simple and looks like standard C++ code.
*/</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">request</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">header</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>     <span class="n">bodySize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">header</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*
* Note: This code is still handling the intricacy of the HTTP protocol
*       so it is brittle. See Protocol/HTTP for help with handling the
*       details of the protocol.
*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s">"Content-Length:"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="n">bodySize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">message</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">line</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">bodySize</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
<span class="p">{</span>
<span class="n">message</span> <span class="o">+=</span> <span class="n">line</span><span class="p">;</span>
<span class="n">message</span> <span class="o">+=</span> <span class="s">"&lt;br&gt;"</span><span class="p">;</span>
<span class="n">bodySize</span> <span class="o">-=</span> <span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
* Note: This code is still handling the intricacy of the HTTP protocol
*       so it is brittle. See Protocol/HTTP for help with handling the
*       details of the protocol.
*/</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"Content-Length: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">11</span> <span class="o">+</span> <span class="n">message</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"It Worked: "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Serv</span><span class="o">::</span><span class="n">Server</span>      <span class="n">server</span><span class="p">;</span>
<span class="n">server</span><span class="p">.</span><span class="n">listenOn</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="n">server</span><span class="p">.</span><span class="n">listenOn</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Serv</span><span class="o">::</span><span class="n">ServerConnection</span><span class="p">(</span><span class="mi">8081</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
<span class="c1">// Start the event loop.
</span>    <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>A simple wrapper around libEvent.
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::Service</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreService/</dd>
<dt>Handler.h</dt><dd></p>
<ul>
<li>class HandlerBase</li>
<li>class HandlerStream: public HandlerBase</li>
<li>class HandlerNonSuspendable: public HandlerStream<Stream></li>
<li>class HandlerSuspendable: public HandlerStream<Stream></li>
<li>class HandlerSuspendableWithStream: public HandlerSuspendable<a href="Socket::DataSocket">Socket::DataSocket</a></li>
</ul>
<p></dd>
<dt>Server.h</dt><dd></p>
<ul>
<li>struct ServerConnection</li>
<li>class Server</li>
</ul>
<p></dd>
<dt>ServerHandlers.h</dt><dd></p>
<ul>
<li>class ServerHandler: public HandlerNonSuspendable<a href="Socket::ServerSocket">Socket::ServerSocket</a></li>
<li>class TimerHandler: public HandlerNonSuspendable<int></li>
</ul>
<p></dd>
</dl></p>
<h3 id='handlerbase'>HandlerBase</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">HandlerBase</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerBase(Server& parent, LibSocketId socketId, short eventType, double timeout = 0)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Protected Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">void</div><div class="methodName">dropHandler()</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">addHandler(Args&&... args)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">moveHandler(Args&&... args)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Virtual Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">short</div><div class="methodName">eventActivate(LibSocketId sockId, short eventType)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">bool</div><div class="methodName">suspendable()</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">suspend(short type)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">close()</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h4 id='handlerbase-eventactivate'>HandlerBase::eventActivate</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">eventActivate(LibSocketId sockId, short eventType)</div></div>
<div class="classRow"><div class="classDesc">
Method called when there is data on the socket.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Return Value</div></div>
<div class="classRow"><div class="classDesc">
Return the type of event that you can next process on this stream: EV_READ or EV_WRITE or (EV_READ | EV_WITE)<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">sockId</div><div class="classValue">The socket with data available on it.</div></div>
<div class="classRow"><div class="classItem">eventType</div><div class="classValue">The type of event that caused this handler to be triggered (EV_READ | EV_WRITE)</div></div>
</div>
<p></div>
</div></p>
<h4 id='handlerbase-suspendable'>HandlerBase::suspendable</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">suspendable()</div></div>
<div class="classRow"><div class="classDesc">
Return true if the handler is suspendable and false otherwise.<br>
It is best to inherit from `HandlerNonSuspendable` or aHandlerNonSuspendable` rather than implement this yourself.<br>
</div></div>
</div>
</div>
</div>
<h4 id='handlerbase-suspend'>HandlerBase::suspend</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">suspend(short type)</div></div>
<div class="classRow"><div class="classDesc">
Suspend the execution of this class until `type` (EV_READ | EV_WRITE) is available for this socket.<br>
This basically returns control to the main event loop until data is available. This is used by the stream handlers to return control to the main event loop if they would block when reading from a stream.<br>
</div></div>
</div>
</div>
</div>
<h4 id='handlerbase-close'>HandlerBase::close</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">close()</div></div>
<div class="classRow"><div class="classDesc">
Close the stream associated with this handler.<br>
</div></div>
</div>
</div>
</div>
<h4 id='handlerbase-drophandler'>HandlerBase::dropHandler</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">dropHandler()</div></div>
<div class="classRow"><div class="classDesc">
When a handler is finished processing events on a stream. It can call dropHandler() to remove itself from the event loop.<br>
This is usually done automatically by higher level derived handlers.<br>
</div></div>
</div>
</div>
</div>
<h4 id='handlerbase-addhandler'>HandlerBase::addHandler</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">addHandler(Args&&... args)</div></div>
<div class="classRow"><div class="classDesc">
If the handler wants to create other handlers.<br>
An example of this is when the SQL handlers are added. They create connections to the SQL server that require their own event handlers.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">args</div><div class="classValue">Arguments passed to the constructor of the new handler</div></div>
</div>
<p></div>
</div></p>
<h4 id='handlerbase-movehandler'>HandlerBase::moveHandler</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">moveHandler(Args&&... args)</div></div>
<div class="classRow"><div class="classDesc">
This is similar to `addHandler()`.<br>
The difference is that the current handler will immediately suspend until the created handler complets.<br>
When the added handler calles `dropHandler()` control will be returned to the current handler at the point it suspended.<br>
Note: The current handler must be suspendable (otherwise an exception is thrown).<br>
See: <a href="HandlerBase::suspendable">HandlerBase::suspendable</a><br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">args</div><div class="classValue">Arguments passed to the constructor of the new handler</div></div>
</div>
<p></div>
</div></p>
<h3 id='handlerstream'>HandlerStream</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">HandlerStream</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerBase</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
This class is templatized based on the type of stream the socket represents.<br>
The class basically defines a common class for holding the stream object and how to close it when requried.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerStream(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">void</div><div class="methodName">close()</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h3 id='handlernonsuspendable'>HandlerNonSuspendable</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">HandlerNonSuspendable</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerStream</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
Defines `suspendable()` and `suspend()` for a class that is non suspendable.<br>
This is used by some of ther server built in handlers that must complete. It is unlikely that this will be useful for a user defined handler.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerNonSuspendable(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">bool</div><div class="methodName">suspendable()</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">suspend(short type)</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h3 id='handlersuspendable'>HandlerSuspendable</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">HandlerSuspendable</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerStream</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
Defines a handler that is suspendable.<br>
Implements `suspendable`, `suspsend()` and `eventActivate()` as these all work together to define a class that can be suspended.<br>
The method `eventActivateNonBlocking()` should be overwridden by derived classes to provide functionaliy.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerSuspendable(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">bool</div><div class="methodName">suspendable()</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">suspend(short type)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">short</div><div class="methodName">eventActivate(LibSocketId sockId, short eventType)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Virtual Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">bool</div><div class="methodName">eventActivateNonBlocking()</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h4 id='handlersuspendable-eventactivatenonblocking'>HandlerSuspendable::eventActivateNonBlocking</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">eventActivateNonBlocking()</div></div>
<div class="classRow"><div class="classDesc">
Called by eventActivate() to start processing of the stream.<br>
If a blocking operation is about to be performed this method should call `suspend()` to return control to the main event loop.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Return Value</div></div>
<div class="classRow"><div class="classDesc">
Return true to cause the handler to be re-used.<br>Return false to not drop the handler. This is used if something clever is happening.<br>
</div></div>
</div>
<p></div>
</div></p>
<h4 id='handlersuspendable-eventactivate'>HandlerSuspendable::eventActivate</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">eventActivate(LibSocketId /*sockId*/, short /*eventType*/)</div></div>
<div class="classRow"><div class="classDesc">
On first call will start the method `eventActivateNonBlocking()`. This method may suspend itself by calling `suspend()`.<br>
On subsequent calls will resume `eventActivateNonBlocking()` at the point where `suspend()` was called.<br>
If `eventActivateNonBlocking()` returns true then `dropHandler()` is called to remove this handler as processing is complete.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Return Value</div></div>
<div class="classRow"><div class="classDesc">
This method returns the type of socket event that should be listend for in the main event loop.<br>
</div></div>
</div>
<p></div>
</div></p>
<h3 id='handlersuspendablewithstream'>HandlerSuspendableWithStream</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">HandlerSuspendableWithStream</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerSuspendable</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
An implementation of `eventActivateNonBlocking()` that creates input and output stream objects.<br>
These stream objects will call `suspend()` if they are about to perform a blocking operation on the underlying socket.<br>
Thus we have transparently non-blocking streams.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerSuspendable(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">bool</div><div class="methodName">eventActivateNonBlocking()</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Virtual Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">bool</div><div class="methodName">eventActivateWithStream(std::istream& input, std::ostream& output)</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h3 id='serverconnection'>ServerConnection</h3><pre class="highlight cpp tab-cpp"><code>    <span class="n">Serv</span><span class="o">::</span><span class="n">Server</span>      <span class="n">server</span><span class="p">;</span>
<span class="c1">// Implicit creation of ServerConnection
</span>    <span class="n">server</span><span class="p">.</span><span class="n">listenOn</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="c1">// Explicit creation of ServerConnection
</span>    <span class="n">server</span><span class="p">.</span><span class="n">listenOn</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Serv</span><span class="o">::</span><span class="n">ServerConnection</span><span class="p">(</span><span class="mi">8081</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</code></pre>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Server.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">struct:  </div><div class="classValue">ServerConnection</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
Used to simplify the definition of a port.<br>
@ See Server::listenOn()<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">ServerConnection(int port, int maxConnections = ThorsAnvil::Nisse::Core::Socket::ServerSocket::maxConnectionBacklog)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Variables:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">int</div><div class="methodName">port</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">int</div><div class="methodName">maxConnections</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h3 id='server'>Server</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Server.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">Server</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
An object that acts as the main server event loop.<br>
One of these objects can handle all the ports your application requires<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Constructor:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet"></div><div class="methodName">Server()</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet"></div><div class="methodName">Server(Server&&)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet"></div><div class="methodName">Server& operator=(Server&&)</div><div class="methodMark"></div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Public Methods:</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="methodRet">void</div><div class="methodName">start(double check = 10.0)</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">flagShutDown()</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">listenOn(ServerConnection const& info[, Param& param])</div><div class="methodMark"></div></div>
<div class="classRow"><div class="methodRet">void</div><div class="methodName">addTimer(double timeOut, std::function<void()>&& action)</div><div class="methodMark"></div></div>
</div>
<p></div>
</div></p>
<h4 id='server-start'>Server::start</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">start(double check)</div></div>
<div class="classRow"><div class="classDesc">
Starts the event loop.<br>
This method does not return immediately. A call to <code>flagShutDown()</code> will cause the event loop to exit after the current iteration.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">check</div><div class="classValue">Timeout period after which internal house keeping operations are performed.</div></div>
</div>
<p></div>
</div></p>
<h4 id='server-flagshutdown'>Server::flagShutDown</h4>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">flagShutDown()</div></div>
<div class="classRow"><div class="classDesc">
Marks the event loop for shut down.<br>
After the current iteration of the event loop has finished it will exit. This will cause the `start()` function to return.<br>
</div></div>
</div>
</div>
</div>
<h4 id='server-addtimer'>Server::addTimer</h4><pre class="highlight cpp tab-cpp"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Serv</span><span class="o">::</span><span class="n">Server</span>      <span class="n">server</span><span class="p">;</span>
<span class="n">MyStateObject</span>     <span class="n">state</span><span class="p">;</span>
<span class="n">server</span><span class="p">.</span><span class="n">addTimer</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="p">[](){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Timer</span><span class="se">\n</span><span class="s">"</span><span class="p">;});</span>
<span class="c1">// Start the event loop.
</span>    <span class="c1">// While the event loop is running the timer will be activated every 3.5 seconds
</span>    <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">addTimer(double timeOut, std::function<void()>&& action)</div></div>
<div class="classRow"><div class="classDesc">
Sets a timer to go off every `timeOut` seconds.<br>
The result of the timmer going off is to execute the functot `action`.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">timeOut</div><div class="classValue">The time period (in seconds) between running the action object.</div></div>
<div class="classRow"><div class="classItem">action</div><div class="classValue">Functor that is run every `timeOut` seconds.</div></div>
</div>
<p></div>
</div></p>
<h4 id='server-listenon'>Server::listenOn</h4><pre class="highlight cpp tab-cpp"><code><span class="k">class</span> <span class="nc">MyState</span>
<span class="p">{</span>
<span class="c1">// Stuf
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">MyHandler</span><span class="o">:</span> <span class="k">public</span> <span class="n">Serv</span><span class="o">::</span><span class="n">HandlerSuspendableWithStream</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="c1">// Notice the last parameter is `state`.
</span>        <span class="c1">// This means a state object must be provided to the `listenOn()` method.
</span>        <span class="n">MyHandler</span><span class="p">(</span><span class="n">Serv</span><span class="o">::</span><span class="n">Server</span><span class="o">&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Sock</span><span class="o">::</span><span class="n">DataSocket</span><span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="p">,</span> <span class="n">MyState</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
<span class="o">:</span> <span class="n">HandlerSuspendableWithStream</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span> <span class="n">EV_READ</span><span class="p">)</span>
<span class="p">{}</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">eventActivateWithStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// Stuff }
</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Serv</span><span class="o">::</span><span class="n">Server</span>      <span class="n">server</span><span class="p">;</span>
<span class="n">MyStateObject</span>     <span class="n">state</span><span class="p">;</span>
<span class="c1">// Because we pass state to the `listenOn()` method; this will be passed to the constructor of 
</span>    <span class="c1">// `MyHandler` when it is created. This allows a user defined state object to be used consistently
</span>    <span class="c1">// across all connections.
</span>    <span class="n">server</span><span class="p">.</span><span class="n">listenOn</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8080</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="c1">// Start the event loop.
</span>    <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classSect">listenOn(ServerConnection const& info, Param& param)</div></div>
<div class="classRow"><div class="classDesc">
This is a templatized function. The template type is the type of object that will handle a connection once it has been established.<br>
When a connection is accepted and object of the template type is created and passed a reference to the server, stream and `data` (see parameters)<br>
The object is marked as listening to the accepted socket and when data is available on the socket the <code>eventActivate()</code> method is called allowing the data to be processed.<br>
For more details see <a href="#HandlerBase">HandlerBase</a>.<br>
</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classSect">Parameters</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classItem">port</div><div class="classValue">The port that is being listen too.</div></div>
<div class="classRow"><div class="classItem">param</div><div class="classValue">An optional parameter: A reference to an object that is passed to the constructor of the handler type. This allows a state object to be passed to the constructor.</div></div>
</div>
<p></div>
</div></p>
<h3 id='serverhandler'>ServerHandler</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/ServerHandlers.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">ServerHandler</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerNonSuspendable</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
An implementation of HandlerNonSuspendable that is used to accept connections and create other handlers.<br>
</div></div>
</div>
</div>
</div>
<h3 id='timerhandler'>TimerHandler</h3>
<div class="classTable allowFloat">
<div class="classLayout">
<div class="classBlock">
<div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/ServerHandlers.h</div></div>
<div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
<div class="classRow"><div class="classItem">class:  </div><div class="classValue">TimerHandler</div></div>
<div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerNonSuspendable</div></div>
</div>
<div class="classBlock">
<div class="classRow"><div class="classDesc">
An implementation of HandlerNonSuspendable that is used to implement the timer functionality.<br>
</div></div>
</div>
</div>
</div>
<h2 id='sql'>SQL</h2><pre class="highlight cpp tab-cpp"><code><span class="k">namespace</span> <span class="n">Express</span> <span class="o">=</span> <span class="n">ThorsAnvil</span><span class="o">::</span><span class="n">Nisse</span><span class="o">::</span><span class="n">Protocol</span><span class="o">::</span><span class="n">HTTP</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">SQL</span>     <span class="o">=</span> <span class="n">ThorsAnvil</span><span class="o">::</span><span class="n">SQL</span><span class="p">;</span>
<span class="k">static</span> <span class="n">SQL</span><span class="o">::</span><span class="n">Connection</span> <span class="n">connection</span><span class="p">(</span><span class="s">"mysqlNB://test.com"</span><span class="p">,</span> <span class="s">"test"</span><span class="p">,</span> <span class="s">"testPassword"</span><span class="p">,</span> <span class="s">"test"</span><span class="p">);</span>
<span class="k">static</span> <span class="n">SQL</span><span class="o">::</span><span class="n">Statement</span>  <span class="n">listBeers</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="s">"SELECT Name, Age FROM Beers"</span><span class="p">);</span>
<span class="k">class</span> <span class="nc">MyListBeerHandler</span><span class="o">:</span> <span class="k">public</span> <span class="n">HandlerSuspendable</span><span class="o">&lt;</span><span class="n">DataSocket</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">eventActivateNonBlocking</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">ISocketStream</span>   <span class="n">input</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">request</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>     <span class="n">header</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">header</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">)</span>
<span class="p">{}</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringsttream</span> <span class="n">body</span><span class="p">;</span>
<span class="n">body</span> <span class="o">&lt;&lt;</span> <span class="s">"&lt;html&gt;"</span>
<span class="o">&lt;&lt;</span> <span class="s">"&lt;head&gt;&lt;title&gt;Beer List&lt;/title&gt;&lt;/head&gt;"</span>
<span class="o">&lt;&lt;</span> <span class="s">"&lt;body&gt;"</span>
<span class="o">&lt;&lt;</span> <span class="s">"&lt;h1&gt;Beer List&lt;/h1&gt;"</span>
<span class="o">&lt;&lt;</span> <span class="s">"&lt;ol&gt;"</span><span class="p">;</span>
<span class="c1">// Calling execute() suspends the current handler.
</span>        <span class="c1">// Control is returned (unsuspends the handler) when the execute() function returns.
</span>        <span class="c1">//
</span>        <span class="c1">// The execute function returns when all the rows have been returned from the SQL
</span>        <span class="c1">// DB. The lambda is executes once for each row that is ruturned this allowing us
</span>        <span class="c1">// to build the response as a stream.
</span>        <span class="n">listBeers</span><span class="p">.</span><span class="n">execute</span><span class="p">([</span><span class="o">&amp;</span><span class="n">body</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// This call to the MySQL server is also non blocking.
</span>            <span class="c1">// If the call is going to block control is returned to ThorNisse framework
</span>            <span class="c1">// Allowing another connection to be processed while the MySQL server finishes
</span>            <span class="c1">// Its work.
</span>            <span class="n">body</span> <span class="o">&lt;&lt;</span> <span class="s">"&lt;li&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">"&lt;/li&gt;"</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">body</span> <span class="o">&lt;&lt;</span> <span class="s">"&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt;"</span><span class="p">;</span>
<span class="n">OSocketStream</span>   <span class="n">output</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"Content-Length: "</span> <span class="o">&lt;&lt;</span> <span class="n">body</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
<span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
<span class="o">&lt;&lt;</span> <span class="n">body</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre><pre class="highlight cpp tab-cpp--DeepDive"><code><span class="n">Please</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">ThorSQL</span> <span class="n">library</span> <span class="k">for</span> <span class="n">details</span><span class="p">.</span>
</code></pre>
<p>A PIMPL proxy for the ThorSQL library.<br>
There are no user usable classes in this package. All the classes are used internally by ThorSQL library. There usage is unlocked by using the prefix &quot;mysqlNB&quot; in the connection string.</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::SQL</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreSQL/</dd>
</dl>
<h1 id='protocol'>Protocol</h1><h2 id='simple'>Simple</h2>
<p>A very simple protocol. These classes are used to test the functionality of Core::Service without the extra baggage of the HTTP protocol.
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Protocol::Simple</dd>
<dt>Headers:</dt><dd>ThorsNisseProtocolSimple/</dd>
</dl></p>
<h2 id='http'>HTTP</h2><pre class="highlight cpp tab-cpp--DeepDive"><code><span class="k">class</span> <span class="nc">Site</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Site</span><span class="p">();</span>
<span class="n">Site</span><span class="p">(</span><span class="n">Site</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">Site</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Site</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Site</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">get</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">Action</span><span class="o">&amp;&amp;</span> <span class="n">action</span><span class="p">)</span>    <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Get</span><span class="p">,</span>    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">action</span><span class="p">));}</span>
<span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">Action</span><span class="o">&amp;&amp;</span> <span class="n">action</span><span class="p">)</span>    <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Put</span><span class="p">,</span>    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">action</span><span class="p">));}</span>
<span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">Action</span><span class="o">&amp;&amp;</span> <span class="n">action</span><span class="p">)</span>    <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Delete</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">action</span><span class="p">));}</span>
<span class="kt">void</span> <span class="nf">post</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">Action</span><span class="o">&amp;&amp;</span> <span class="n">action</span><span class="p">)</span>   <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Post</span><span class="p">,</span>   <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">action</span><span class="p">));}</span>
<span class="kt">void</span> <span class="nf">all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">Action</span><span class="o">&amp;&amp;</span> <span class="n">action</span><span class="p">)</span>    <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">action</span><span class="p">));}</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Action</span><span class="o">&gt;</span> <span class="n">find</span><span class="p">(</span><span class="n">Method</span> <span class="n">method</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Binder</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Binder</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">setCustome404Action</span><span class="p">(</span><span class="n">Action</span><span class="o">&amp;&amp;</span> <span class="n">action</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">addSite</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">base</span><span class="p">,</span> <span class="n">Site</span><span class="o">&amp;&amp;</span> <span class="n">site</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">remSite</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">base</span><span class="p">);</span>
<span class="n">Action</span> <span class="n">find</span><span class="p">(</span><span class="n">Method</span> <span class="n">method</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">DeveloperHandler</span><span class="o">:</span> <span class="k">public</span> <span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="o">::</span><span class="n">HandlerNonSuspendable</span><span class="o">&lt;</span><span class="n">Core</span><span class="o">::</span><span class="n">Socket</span><span class="o">::</span><span class="n">DataSocket</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">DeveloperHandler</span><span class="p">(</span><span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="o">::</span><span class="n">Server</span><span class="o">&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Core</span><span class="o">::</span><span class="n">Socket</span><span class="o">::</span><span class="n">DataSocket</span><span class="o">&amp;&amp;</span> <span class="n">socket</span><span class="p">,</span> <span class="n">DynamicSiteLoader</span><span class="o">&amp;</span> <span class="n">loader</span><span class="p">);</span>
<span class="k">virtual</span> <span class="kt">short</span> <span class="n">eventActivate</span><span class="p">(</span><span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="o">::</span><span class="n">LibSocketId</span> <span class="n">sockId</span><span class="p">,</span> <span class="kt">short</span> <span class="n">eventType</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">DynamicSiteLoader</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">DynamicSiteLoader</span><span class="p">(</span><span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="o">::</span><span class="n">Server</span><span class="o">&amp;</span> <span class="n">server</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>      <span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">site</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">base</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">unload</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">base</span><span class="p">);</span>
<span class="kt">void</span>                       <span class="n">setMaxWaitingConnections</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">ReadRequestHandler</span><span class="o">:</span> <span class="k">public</span> <span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="o">::</span><span class="n">HandlerSuspendable</span><span class="o">&lt;</span><span class="n">Core</span><span class="o">::</span><span class="n">Socket</span><span class="o">::</span><span class="n">DataSocket</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">ReadRequestHandler</span><span class="p">(</span><span class="n">Core</span><span class="o">::</span><span class="n">Service</span><span class="o">::</span><span class="n">Server</span><span class="o">&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Core</span><span class="o">::</span><span class="n">Socket</span><span class="o">::</span><span class="n">DataSocket</span><span class="o">&amp;&amp;</span> <span class="n">socket</span><span class="p">,</span> <span class="n">Binder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">binder</span><span class="p">);</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">eventActivateNonBlocking</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">setFlusher</span><span class="p">(</span><span class="n">Response</span><span class="o">*</span> <span class="n">f</span><span class="p">){</span><span class="n">flusher</span> <span class="o">=</span> <span class="n">f</span><span class="p">;}</span>
<span class="kt">void</span> <span class="n">flushing</span><span class="p">()</span>             <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="n">flusher</span><span class="p">){</span><span class="n">flusher</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">();}}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">HttpParserData</span>
<span class="p">{</span>
<span class="n">HttpParserData</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">addCurrentHeader</span><span class="p">();</span>
<span class="n">Headers</span>                 <span class="n">headers</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>             <span class="n">currentHead</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>             <span class="n">currentValue</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>             <span class="n">uri</span><span class="p">;</span>
<span class="kt">char</span> <span class="k">const</span><span class="o">*</span>             <span class="n">bodyBegin</span><span class="p">;</span>
<span class="kt">char</span> <span class="k">const</span><span class="o">*</span>             <span class="n">bodyEnd</span><span class="p">;</span>
<span class="n">Method</span>                  <span class="n">method</span><span class="p">;</span>
<span class="kt">bool</span>                    <span class="n">messageComplete</span><span class="p">;</span>
<span class="kt">bool</span>                    <span class="n">gotValue</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">HttpScanner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">HttpParserData</span>          <span class="n">data</span><span class="p">;</span>
<span class="n">HttpScanner</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">scan</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Route</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Route</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">fullRoute</span><span class="p">);</span>
<span class="n">Route</span><span class="p">(</span><span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>            <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">Route</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">Route</span><span class="p">(</span><span class="n">Route</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">RouteTester</span>
<span class="p">{</span>
<span class="k">using</span> <span class="n">is_transparent</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">rhs</span> <span class="o">&lt;=</span> <span class="n">lhs</span><span class="p">);}</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">;}</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Route</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>       <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">;}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Headers</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="k">typedef</span> <span class="n">ConstIterator</span> <span class="n">const_iterator</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Inserter</span>
<span class="p">{</span>
<span class="n">ValueStore</span><span class="o">&amp;</span>  <span class="n">valueStore</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Inserter</span><span class="p">(</span><span class="n">ValueStore</span><span class="o">&amp;</span> <span class="n">valueStore</span><span class="p">);</span>
<span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">ConstIterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">data</span><span class="p">);}</span>
<span class="n">ConstIterator</span> <span class="n">end</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">data</span><span class="p">);}</span>
<span class="n">Inserter</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>    <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">];}</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>        <span class="n">getVersions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">URI</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">original</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">normalized</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">schema</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">host</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">query</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fragment</span><span class="p">;</span>
<span class="kt">short</span>       <span class="n">port</span><span class="p">;</span>
<span class="n">Headers</span>     <span class="n">queryParam</span><span class="p">;</span>
<span class="n">URI</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hostAndPort</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">pathAndQuery</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Request</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="k">const</span> <span class="n">Method</span>            <span class="n">method</span><span class="p">;</span>
<span class="k">const</span> <span class="n">URI</span>               <span class="n">uri</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Headers</span><span class="o">&amp;</span>          <span class="n">headers</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span>           <span class="n">body</span><span class="p">;</span>
<span class="n">Request</span><span class="p">(</span><span class="n">Method</span> <span class="n">method</span><span class="p">,</span>
<span class="n">URI</span><span class="o">&amp;&amp;</span> <span class="n">uri</span><span class="p">,</span>
<span class="n">Headers</span><span class="o">&amp;</span> <span class="n">headers</span><span class="p">,</span>
<span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Response</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="kt">short</span>                   <span class="n">resultCode</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>             <span class="n">resultMessage</span><span class="p">;</span>
<span class="n">Headers</span>                 <span class="n">headers</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span>           <span class="n">body</span><span class="p">;</span>
<span class="n">Response</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">);</span>
<span class="n">Response</span><span class="p">(</span><span class="n">ReadRequestHandler</span><span class="o">&amp;</span> <span class="n">flusher</span><span class="p">,</span>
<span class="n">DataSocket</span><span class="o">&amp;</span> <span class="n">socket</span><span class="p">,</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">,</span>
<span class="kt">short</span> <span class="n">resultCode</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">resultMessage</span> <span class="o">=</span> <span class="s">"OK"</span><span class="p">);</span>
<span class="o">~</span><span class="n">Response</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">flushing</span><span class="p">(</span><span class="kt">bool</span> <span class="n">allDone</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
<p>An implementation of the HTTP protocol
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Protocol::HTTP</dd>
<dt>Headers:</dt><dd>ThorsNisseProtocolHTTP/</dd>
<dt>Binder.h</dt><dd></p>
<ul>
<li>class Site</li>
<li>class Binder</li>
</ul>
<p></dd>
<dt>DeveloperHandler.h</dt><dd></p>
<ul>
<li>class DeveloperHandler: public Core::Service::HandlerNonSuspendable</li>
</ul>
<p></dd>
<dt>DynamicSiteLoader.h</dt><dd></p>
<ul>
<li>class DynamicSiteLoader</li>
</ul>
<p></dd>
<dt>HTTPProtocol.h</dt><dd></p>
<ul>
<li>class ReadRequestHandler: public Core::Service::HandlerSuspendable</li>
</ul>
<p></dd>
<dt>HttpScanner.h</dt><dd></p>
<ul>
<li>struct HttpParserData</li>
<li>class HttpScanner</li>
</ul>
<p></dd>
<dt>Route.h</dt><dd></p>
<ul>
<li>class Route</li>
<li>struct RouteTester</li>
</ul>
<p></dd>
<dt>Types.h</dt><dd></p>
<ul>
<li>class Headers</li>
<li>class URI</li>
<li>class Request</li>
<li>class Response</li>
</ul>
<p></dd>
</dl></p>
<h1 id='examples'>Examples</h1>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</p>
<h2 id='addbeer'>AddBeer</h2>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</p>
</div>
<div class="dark-box">
</div>
</div>
</body>
</html>
