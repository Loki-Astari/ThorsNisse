<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <link href="stylesheet/style.css" rel="stylesheet" />
    <link href="stylesheet/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheet/print.css" rel="stylesheet" media="print" />
    <script src="javascripts/all_nosearch.js"></script>
</head>


    <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
    <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
    </span>
</a>

    <div class="toc-wrapper">
    <img src="images/logo.png" class="logo" alt="Logo" />
    <div id="toc" class="toc-list-h1">
        
    <li>
        <a href="#introduction" class="toc-h1 toc-link" data-title="Introduction">Introduction</a>
        
    </li>

    <li>
        <a href="#node-cxx" class="toc-h1 toc-link" data-title="Node.Cxx">Node.Cxx</a>
        
    </li>

    <li>
        <a href="#express" class="toc-h1 toc-link" data-title="Express">Express</a>
        
    </li>

    <li>
        <a href="#core" class="toc-h1 toc-link" data-title="Core">Core</a>
        
            <ul class="toc-list-h2">
                
    <li>
        <a href="#utility" class="toc-h2 toc-link" data-title="Core">Utility</a>
        
    </li>

    <li>
        <a href="#socket" class="toc-h2 toc-link" data-title="Core">Socket</a>
        
            <ul class="toc-list-h3">
                
    <li>
        <a href="#basesocket" class="toc-h3 toc-link" data-title="Core">BaseSocket</a>
        
    </li>

    <li>
        <a href="#datasocket" class="toc-h3 toc-link" data-title="Core">DataSocket</a>
        
    </li>

    <li>
        <a href="#connectionsocket" class="toc-h3 toc-link" data-title="Core">ConnectionSocket</a>
        
    </li>

    <li>
        <a href="#serversocket" class="toc-h3 toc-link" data-title="Core">ServerSocket</a>
        
    </li>

    <li>
        <a href="#socketstreambuffer" class="toc-h3 toc-link" data-title="Core">SocketStreamBuffer</a>
        
    </li>

    <li>
        <a href="#isocketstream" class="toc-h3 toc-link" data-title="Core">ISocketStream</a>
        
    </li>

    <li>
        <a href="#osocketstream" class="toc-h3 toc-link" data-title="Core">OSocketStream</a>
        
    </li>



            </ul>
        
    </li>

    <li>
        <a href="#service" class="toc-h2 toc-link" data-title="Core">Service</a>
        
            <ul class="toc-list-h3">
                
    <li>
        <a href="#handlerbase" class="toc-h3 toc-link" data-title="Core">HandlerBase</a>
        
    </li>

    <li>
        <a href="#handlerstream" class="toc-h3 toc-link" data-title="Core">HandlerStream</a>
        
    </li>

    <li>
        <a href="#handlernonsuspendable" class="toc-h3 toc-link" data-title="Core">HandlerNonSuspendable</a>
        
    </li>

    <li>
        <a href="#handlersuspendable" class="toc-h3 toc-link" data-title="Core">HandlerSuspendable</a>
        
    </li>

    <li>
        <a href="#handlersuspendablewithstream" class="toc-h3 toc-link" data-title="Core">HandlerSuspendableWithStream</a>
        
    </li>

    <li>
        <a href="#serverconnection" class="toc-h3 toc-link" data-title="Core">ServerConnection</a>
        
    </li>

    <li>
        <a href="#server" class="toc-h3 toc-link" data-title="Core">Server</a>
        
    </li>

    <li>
        <a href="#serverhandler" class="toc-h3 toc-link" data-title="Core">ServerHandler</a>
        
    </li>

    <li>
        <a href="#timerhandler" class="toc-h3 toc-link" data-title="Core">TimerHandler</a>
        
    </li>



            </ul>
        
    </li>

    <li>
        <a href="#sql" class="toc-h2 toc-link" data-title="Core">SQL</a>
        
    </li>



            </ul>
        
    </li>

    <li>
        <a href="#protocol" class="toc-h1 toc-link" data-title="Protocol">Protocol</a>
        
            <ul class="toc-list-h2">
                
    <li>
        <a href="#simple" class="toc-h2 toc-link" data-title="Protocol">Simple</a>
        
    </li>

    <li>
        <a href="#http" class="toc-h2 toc-link" data-title="Protocol">HTTP</a>
        
    </li>



            </ul>
        
    </li>

    <li>
        <a href="#examples" class="toc-h1 toc-link" data-title="Examples">Examples</a>
        
            <ul class="toc-list-h2">
                
    <li>
        <a href="#addbeer" class="toc-h2 toc-link" data-title="Examples">AddBeer</a>
        
    </li>



            </ul>
        
    </li>



    </div>
    <ul class="toc-footer">
        <li><a href="">Generated by Andvari</a><br>
            <a href="https://github.com/Loki-Astari/andvari-theme-documentation">using andvari-theme-documentation</a>
        </li>
    </ul>
</div>

    <div class="page-wrapper">
    <div class="dark-box"></div>
    <div class="content">
        
    <h1 id="introduction">Introduction</h1>
    
    
                <p><a href="https://github.com/Loki-Astari/ThorsNisse">ThorsNisse</a> is RESTful server framework for C++.<br />
It is based on Node.js and its family of associated packages. ThorsNisse uses transparently non-blocking <code>std::streams</code> to achieve high throughput and low complexity of development on a single threaded server.</p>
<p>What does <strong>transparently non-blocking:</strong> mean?</p>
<ul>
<li>To the user of the std::stream it will appear to be standard blocking stream; thus allowing very normal looking C++ code to be written.</li>
<li>To make the framework efficient any blocking read/write calls transfers control back to the Nisse Framework so that other streams may be processed.</li>
</ul>
    
    
    

    <h1 id="node-cxx">Node.Cxx</h1>
    
    
                <p>To simplify development for those that simply want to write HTTP RESTful endpoints the server Node.Cxx is provided to handle all the boilerplate.</p>
<p>Node.Cxx (Lovingly named after Node.js for the inspiration) is a simple HTTP server implemented using the ThorsNisse framework that will dynamically load <a href="#express">Express</a> modules.</p>
<p>The Node.Cxx server takes two flags as arguments on startup:</p>
<pre><code class="bash language-bash"> &gt; Node.cxx [--debug:&lt;port&gt;] [--load:&lt;SharedLib&gt;:&lt;Host&gt;:&lt;Base&gt;:&lt;port&gt;]
 #
 # --debug:8081
 #      Loads the dynamic loader so it listens on port 8081
 #          To load a libray:
 #              curl --data '{"action": "Load",   "host": "test.com", "base": "", "port": 8080, "lib": "AddBeer.dylib"}' localhost:8081
 #          To unload a library:
 #              curl --data '{"action": "Unload", "host": "test.com", "base": "", "port": 8080}'  localhost:8081
 #
 #
 # --load:AddBeer.dylib:test.com::8080
 #      Loads the AddBeer.dylib express module.
 #          And binds it to the root of http://test.com
 #
 #          Assume AddBeer defines the end pointes /AddBeer
 #          When a request to `http://test.com/AddBeer the associated code will be called.
 #
 # --load:AddDrink.dylib:test.com:/drinks:8080
 #      Loads the AddDrink.dylib express module.
 #          And binds it to http://test.com/drinks
 #
 #          Assume AddDrink defines the end pointes /AddDrink
 #          When a request to `http://test.com/drinks/AddDrink the associated code will be called.
 #
 #          Note we did not bind AddDrink to the root of test.com so you need to add the `Base` to
 #          all routes defined by the library in its code.
</code></pre>
<p>|Command Line Flag        | Description
|------------|------------
|--debug     | Installs the dynamic library loader.<br>This allows shared libraries to be loaded/unloaded at runtime without restarting the server. Useful for building and debugging but should not be used in production.<br><br>As the command to load/unload library is simply a REST call to the specified port; this can be included into your build environment to un-install the old version and install the newly build version allowing a quick turn around for development.
|--load      | Loads a shared library that is linked with <a href="#express">Express</a>.<br>This flag can be used multiple times.<br><br>The express module provides the facility to easily associate code with REST end points.<br><br>This flag uses the same underlying code as the REST call to load a site. So these sites can also be dynamically unloaded if required.</p>
    
    
    

    <h1 id="express">Express</h1>
    
    
                <pre><code class="cpp language-cpp">// Must include this header
#include "ThorsExpress/all.h"

namespace HTTP = ThorsAnvil::Nisse::Protocol::HTTP;

// Must define this function once.
void addSite(HTTP::Site&amp; site)
{
    site.get("/listBeer", [](HTTP::Request&amp; request, HTTP::Response&amp; response)
    {
    });
    // You can add as many resources to as site as you need.
}
</code></pre>
<p>Express is a simple library that allows the definition of simple HTTP site modules that can be loaded/unload dynamically. Though each site object is simple each one can be bound to a different relative paths on a site.</p>
    
    
    

    <h1 id="core">Core</h1>
    
    
        
    <h2 id="utility">Utility</h2>
    
    
                <pre><code class="cpp language-cpp">if (open("file", O_WRONLY) == -1)
{
    throw std::runtime_error(
        buildErrorMessage("MyClass::", __func__,
                          ": open: ", Utility::systemErrorMessage()));
}
</code></pre>
<pre><code class="cpp--DeepDive language-cpp--DeepDive">// Utility.h
/*
 * Builds a string for a system error message.
 * uses `errno` to build the name of the error and the associated message into a string.
 */
inline std::string systemErrorMessage();

/*
 * Build an error message from a set of parameters.
 * Slightly more compact than using 'operator&lt;&lt;` very useful for building exception messages.
 */
template&lt;typename... Args&gt;
std::string buildErrorMessage(Args const&amp;... args);
</code></pre>
<p>Provides common utility functions for other packages.</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::Utility</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreUtility/</dd>
<dt>Utility.h</dt><dd>

* std::string systemErrorMessage();
* std::string buildErrorMessage();

</dd>
</dl>
    
    
    

    <h2 id="socket">Socket</h2>
    
    
                <pre><code class="bash language-bash"> &gt; g++ Socket.cpp -o Socket -I${THOR_ROOT}/include -L${THOR_ROOT}/lib -lThorsExpress17
 &gt; curl --data "A test message in a bottle :)" http://localhost:8080;echo
</code></pre>
<pre><code class="cpp language-cpp">// Server Side
#include "ThorsNisseCoreSocket/Socket.h"
#include "ThorsNisseCoreSocket/SocketStream.h"
#include &lt;string&gt;
int main()
{
    namespace Sock = ThorsAnvil::Nisse::Core::Socket;

    Sock::ServerSocket    server(8080);
    while(true)
    {
        Sock::DataSocket    connection = server.accept();
        Sock::ISocketStream input(connection);

        std::string     request;
        std::getline(input, request);

        std::string     header;
        std::size_t     bodySize = 0;
        while(std::getline(input, header) &amp;&amp; header != "\r")
        {
            /*
             * Note: This code is still handling the intricacy of the HTTP protocol
             *       so it is brittle. See Protocol/HTTP for help with handling the
             *       details of the protocol.
             */
            if (header.compare(0, 15, "Content-Length:") == 0) {
                bodySize = std::stoi(header.substr(15));
            }
        }

        std::string     message;
        std::string     line;
        while(bodySize &gt; 0 &amp;&amp; std::getline(input, line))
        {
            message += line;
            message += "&lt;br&gt;";
            bodySize -= (line.size() + 1);
        }

        Sock::OSocketStream output(connection);
        /*
         * Note: This code is still handling the intricacy of the HTTP protocol
         *       so it is brittle. See Protocol/HTTP for help with handling the
         *       details of the protocol.
         */
        output &lt;&lt; "HTTP/1.1 200 OK\r\n"
                  "Content-Length: " &lt;&lt; (11 + message.size()) &lt;&lt; "\r\n"
                  "\r\n"
                  "It Worked: " &lt;&lt; message;
    }
}
</code></pre>
<p>A simple wrapper around BSD sockets so they are easy to use in C++.</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::Socket</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreSocket/</dd>
<dt>Socket.h</dt><dd>

* class BaseSocket
* class DataSocket: public BaseSocket
* class ConnectionSocket: public DataSocket
* class ServerSocket: public BaseSocket

</dd>
<dt>SocketStream.h</dt><dd>

* class SocketStreamBuffer: public std::streambuf
* class ISocketStream: public std::istream
* class OSocketStream: public std::ostream

</dd>
</dl>
<h3 id="basesocket">BaseSocket</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">BaseSocket</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">Base of all the socket classes.<br>
            This class should not be directly created.<br>
            All socket classes are movable but not copyable.</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">BaseSocket(BaseSocket&&)</div><div class="methodMark">noexcept</div></div>
            <div class="classRow"><div class="methodRet">BaseSocket&</div><div class="methodName">operator=(BaseSocket&&)</div><div class="methodMark">noexcept</div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">swap(BaseSocket&)</div><div class="methodMark">noexcept</div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">close()</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="datasocket">DataSocket</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">DataSocket</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">BaseSocket</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            Data sockets define the read/write interface to a socket.<br>
            This class should not be directly created
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet">std::pair&lt;bool, std::size_t&gt;</div><div class="methodName">getMessageData(char* buffer, std::size_t size, std::size_t alreadyGot = 0)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">std::pair&lt;bool, std::size_t&gt;</div><div class="methodName">putMessageData(char const* buffer, std::size_t size, std::size_t alreadyPut = 0)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">putMessageClose()</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h4 id="datasocketgetmessagedata">DataSocket::getMessageData</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">getMessageData()</div></div>
            <div class="classRow"><div class="classDesc">
            Reads data from a sokcet into a buffer.<br>
            If the stream is blocking will not return until the requested amount of data has been read or there is no more data to read.<br>
            If the stream in non blocking will return if the read operation would block.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value</div></div>
            <div class="classRow"><div class="classDesc">
            This method returns a pair: <code>std::pair&lt;bool, std::size_t&gt;</code><br>
            The first member `bool` indicates if more data can potentially be read from the stream. If the socket was cut or the EOF reached then this value will be false<br>
            The second member `std::size_t` indicates exactly how many bytes were read from this stream.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">buffer</div><div class="classValue">The buffer data will be read into.</div></div>
            <div class="classRow"><div class="classItem">size</div><div class="classValue">The size of the buffer.</div></div>
            <div class="classRow"><div class="classItem">alreadyGot</div><div class="classValue">Offset into buffer (and amount size is reduced by) as this amount was read on a previous call).</div></div>
        </div>
    </div>
</div>
<h4 id="datasocketputmessagedata">DataSocket::putMessageData</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">putMessageData()</div></div>
            <div class="classRow"><div class="classDesc">
            Writes data from a buffer to a sokcet.<br>
            If the stream is blocking will not return until the requested amount of data has been written or the socket was closed to writting.<br>
            If the stream in non blocking will return if the write operation would block.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value</div></div>
            <div class="classRow"><div class="classDesc">
            This method returns a pair: <code>std::pair&lt;bool, std::size_t&gt;</code><br>
            The first member `bool` indicates if more data can potentially be written to the stream. If the socket was cut or closed then this value will be false<br>
            The second member `std::size_t` indicates exactly how many bytes were written to this stream.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">buffer</div><div class="classValue">The buffer data will be written from.</div></div>
            <div class="classRow"><div class="classItem">size</div><div class="classValue">The size of the buffer.</div></div>
            <div class="classRow"><div class="classItem">alreadyPut</div><div class="classValue">Offset into buffer (and amount size is reduced by) as this amount was written on a previous call).</div></div>
        </div>
    </div>
</div>
<h4 id="datasocketputmessageclose">DataSocket::putMessageClose</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">putMessageClose()</div></div>
            <div class="classRow"><div class="classDesc">
            closes the write end of the socket and flushes (write) data.
            </div></div>
        </div>
    </div>
</div>
<h3 id="connectionsocket">ConnectionSocket</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ConnectionSocket</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">DataSocket</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            Creates a connection to <code>host</code> on <code>port</code>.<br>
            Note this class inherits from <code>DataSocket</code> so once created you can read/write to the socket.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">ConnectionSocket(std::string const& host, int port)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="serversocket">ServerSocket</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/Socket.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ServerSocket</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">BaseSocket</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">ServerSocket(int port, bool blocking, int maxWaitConnections = ServerSocket::maxConnectionBacklog)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">DataSocket</div><div class="methodName">accept(bool blocking)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h4 id="serversocketaccept">ServerSocket::accept</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">accept()</div></div>
            <div class="classRow"><div class="classDesc">
            "Accept" a waiting connection request on the port and creates a two way socket for communication on another port.<br>
            If this is a non blocking socket and there is no waiting connection an exception is thrown.<br>
            If this is a blocking socket wait for a connection<br>
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value</div></div>
            <div class="classRow"><div class="classDesc">
            A <code>DataSocket</code> is returned so data can be exchange across the socket.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">blocking</div><div class="classValue">Passed to the constructor of the <code>DataSocket</code> that is returned.</div></div>
        </div>
    </div>
</div>
<h3 id="socketstreambuffer">SocketStreamBuffer</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/SocketStream.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">SocketStreamBuffer</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">std::streambug</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            This is a wrapper class for a <code>DataSocket</code> that allows the socket to be treated like <code>std::streambuf</code>.<br>
            This class overrides just enough virtual functions to make the <code>ISocketStream</code> and <code>OSocketStream</code> useful.<br>
            This class provides no public API and is designed to be used solely with the following stream objects.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
    </div>
</div>
<h3 id="isocketstream">ISocketStream</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/SocketStream.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ISocketStream</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">std::istream</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            An implementation of <code>std::istream</code> that uses <code>SocketStreamBuffer</code> as the buffer.<br>
            The <code>Notofer</code> is a primitive event callback mechanism.<br>
            A blocking read call to these streams calls the <code>Notifier noData</code>. This is used by the <a href="#Server">Server</a> infastructure to yield control back to the main event loop.<br>
            <code>using Notifier = std::function<void()>;</code>
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">ISocketStream(DataSocket& stream, Notifier noData, Notfier flush)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div><div class="methodName">ISocketStream(DataSocket& stream)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div><div class="methodName">ISocketStream(ISocketStream&& move)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="osocketstream">OSocketStream</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreSocket/SocketStream.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Socket</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">OSocketStream</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">std::istream</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            An implementation of <code>std::ostream</code> that uses <code>SocketStreamBuffer</code> as the buffer.<br>
            The <code>Notofer</code> is a primitive event callback mechanism.
            A blocking write call to these streams calls the <code>Notifier noData</code>. This is used by the <a href="#Server">Server</a> infastructure to yield control back to the main event loop.<br>
            <code>using Notifier = std::function<void()>;</code>
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">OSocketStream(DataSocket& stream, Notifier noData, Notfier flush)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div><div class="methodName">OSocketStream(DataSocket& stream)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div><div class="methodName">OSocketStream(OSocketStream&& move)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
    
    
    
        
    <h3 id="basesocket">BaseSocket</h3>
    
    

    <h3 id="datasocket">DataSocket</h3>
    
    

    <h3 id="connectionsocket">ConnectionSocket</h3>
    
    

    <h3 id="serversocket">ServerSocket</h3>
    
    

    <h3 id="socketstreambuffer">SocketStreamBuffer</h3>
    
    

    <h3 id="isocketstream">ISocketStream</h3>
    
    

    <h3 id="osocketstream">OSocketStream</h3>
    
    


    

    <h2 id="service">Service</h2>
    
    
                <pre><code class="bash language-bash"> &gt; g++ -std=c++1z Server.cpp -o Server -I${THOR_ROOT}/include -L${THOR_ROOT}/lib -lThorsExpress17 -lboost_context-mt
 &gt; curl --data "A test message in a bottle :)" http://localhost:8080;echo
</code></pre>
<pre><code class="cpp language-cpp">#include "ThorsNisseCoreService/Server.h"
#include "ThorsNisseCoreService/Handler.h"
#include "ThorsNisseCoreSocket/Socket.h"
#include "ThorsNisseCoreSocket/SocketStream.h"
#include &lt;string&gt;

namespace Serv = ThorsAnvil::Nisse::Core::Service;
namespace Sock = ThorsAnvil::Nisse::Core::Socket;

class MyHandler: public Serv::HandlerSuspendableWithStream
{
    public:
        MyHandler(Serv::Server&amp; parent, Sock::DataSocket&amp;&amp; stream)
            : HandlerSuspendableWithStream(parent, std::move(stream), EV_READ)
        {}
        virtual bool eventActivateWithStream(std::istream&amp; input, std::ostream&amp; output)
        {
            /*
             * Note: The streams `input` and `output` are transparently non-blocking.
             *       Any blocking read/write will transfer control back to the server
             *       event loop.
             *
             * To the code in this function any read/write requests appear to be blocking
             * So the writting code is still simple and looks like standard C++ code.
             */
            std::string     request;
            std::getline(input, request);

            std::string     header;
            std::size_t     bodySize = 0;
            while(std::getline(input, header) &amp;&amp; header != "\r")
            {
                /*
                 * Note: This code is still handling the intricacy of the HTTP protocol
                 *       so it is brittle. See Protocol/HTTP for help with handling the
                 *       details of the protocol.
                 */
                if (header.compare(0, 15, "Content-Length:") == 0) {
                    bodySize = std::stoi(header.substr(15));
                }
            }

            std::string     message;
            std::string     line;
            while(bodySize &gt; 0 &amp;&amp; std::getline(input, line))
            {
                message += line;
                message += "&lt;br&gt;";
                bodySize -= (line.size() + 1);
            }

            /*
             * Note: This code is still handling the intricacy of the HTTP protocol
             *       so it is brittle. See Protocol/HTTP for help with handling the
             *       details of the protocol.
             */
            output &lt;&lt; "HTTP/1.1 200 OK\r\n"
                      "Content-Length: " &lt;&lt; (11 + message.size()) &lt;&lt; "\r\n"
                      "\r\n"
                      "It Worked: " &lt;&lt; message;
            return true;
        }
};
int main()
{
    Serv::Server      server;
    server.listenOn&lt;MyHandler&gt;(8080);
    server.listenOn&lt;MyHandler&gt;(Serv::ServerConnection(8081, 20));

    // Start the event loop.
    server.start();
}
</code></pre>
<p>A simple wrapper around libEvent.</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::Service</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreService/</dd>
<dt>Server.h</dt><dd>

* struct ServerConnection
* class Server

</dd>
<dt>Handler.h</dt><dd>

* class HandlerBase
* class HandlerStream: public HandlerBase
* class HandlerNonSuspendable: public HandlerStream
* class HandlerSuspendable: public HandlerStream

</dd>
<dt>ServerHandlers.h</dt><dd>

* class ServerHandler: public HandlerNonSuspendable
* class TimerHandler: public HandlerNonSuspendable

</dd>
</dl>
<h3 id="serverconnection">ServerConnection</h3>
<pre><code class="cpp language-cpp">    Serv::Server      server;
    // Implicit creation of ServerConnection
    server.listenOn&lt;MyHandler&gt;(8080);
    // Explicit creation of ServerConnection
    server.listenOn&lt;MyHandler&gt;(Serv::ServerConnection(8081, 20));
</code></pre>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Server.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Struct:   </div><div class="classValue">ServerConnection</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">ServerConnection(int port, int maxConnections)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">int</div><div class="methodName">port</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">int</div><div class="methodName">maxConnections</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="server">Server</h3>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Server.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">Server</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">Server()</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div><div class="methodName">Server(Server&&)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div><div class="methodName">Server& operator=(Server&&)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">start(double check = 10.0)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">flagShutDown()</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">listenOn(ServerConnection const& info, Param& param)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">addTimer(double timeOut, std::function<void()>&& action)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h4 id="serverstart">Server::start</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">start(double check = 10.0)</div></div>
            <div class="classRow"><div class="classDesc">
            Starts the event loop.<br>
            This method does not return immediately. A call to <code>flagShutDown()</code> will cause the event loop to exit after the current iteration.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">check</div><div class="classValue">Timeout period after which internal house keeping operations are performed.</div></div>
        </div>
    </div>
</div>
<h4 id="serverflagshutdown">Server::flagShutDown</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">flagShutDown()</div></div>
            <div class="classRow"><div class="classDesc">
            Marks the event loop for shut down.<br>
            After the current iteration of the event loop has finished it will exit. This will cause the `start()` function to return.
            </div></div>
        </div>
    </div>
</div>
<h4 id="serverlistenon">Server::listenOn</h4>
<pre><code class="cpp language-cpp">class MyState
{
    // Stuf
};
class MyHandler: public Serv::HandlerSuspendableWithStream
{
    public:
        // Notice the last parameter is `state`.
        // This means a state object must be provided to the `listenOn()` method.
        MyHandler(Serv::Server&amp; parent, Sock::DataSocket&amp;&amp; stream, MyState&amp; state)
            : HandlerSuspendableWithStream(parent, std::move(stream), EV_READ)
        {}

        virtual bool eventActivateWithStream(std::istream&amp; input, std::ostream&amp; output)
        { // Stuff }
};
int main()
{
    Serv::Server      server;
    MyStateObject     state;

    // Because we pass state to the `listenOn()` method; this will be passed to the constructor of 
    // `MyHandler` when it is created. This allows a user defined state object to be used consistently
    // across all connections.
    server.listenOn&lt;MyHandler&gt;(8080, state);

    // Start the event loop.
    server.start();
}
</code></pre>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">listenOn(int port, Param& data)</div></div>
            <div class="classRow"><div class="classDesc">
            This is a templatized function. The template type is the type of object that will handle a connection once it has been established.<br>
            When a connection is accepted and object of the template type is created and passed a reference to the server, stream and `data` (see parameters)<br>
            The object is marked as listening to the accepted socket and when data is available on the socket the <code>eventActivate()</code> method is called allowing the data to be processed.<br>
            For more details see <a href="#HandlerBase">HandlerBase</a>.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">port</div><div class="classValue">The port that is being listen too.</div></div>
            <div class="classRow"><div class="classItem">data</div><div class="classValue">A reference to an object that is passed to the constructor of the handler type. This allows a state object to be passed to the constructor</div></div>
        </div>
    </div>
</div>
<h4 id="serveraddtimer">Server::addTimer</h4>
<pre><code class="cpp language-cpp">int main()
{
    Serv::Server      server;
    MyStateObject     state;

    server.addTimer(3.5, [](){std::cout &lt;&lt; "Timer\n";});

    // Start the event loop.
    // While the event loop is running the timer will be activated every 3.5 seconds
    server.start();
}
</code></pre>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">addTimer(double timeOut, std::function<void()>&& action)</div></div>
            <div class="classRow"><div class="classDesc">
            Sets a timer to go off every `timeOut` seconds.<br>
            The result of the timmer going off is to execute the functot `action`.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">timeOut</div><div class="classValue">The time period (in seconds)  between running the action object.</div></div>
            <div class="classRow"><div class="classItem">action</div><div class="classValue">Functor that is run every `timeOut` seconds..</div></div>
        </div>
    </div>
</div>
<h3 id="handlerbase">HandlerBase</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">HandlerBase</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerBase(Server& parent, LibSocketId socketId, short eventType, double timeout = 0)</div><div class="methodMark"></div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Protected Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">dropHandler()</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">addHandler(Args&&... args)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">moveHandler(Args&&... args)</div><div class="methodMark"></div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Virtual Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet">short</div><div class="methodName">eventActivate(LibSocketId sockId, short eventType)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">bool</div><div class="methodName">suspendable()</div><div class="methodMark"></div></div>
            <div class="classROw"><div class="methodRet">void</div><div class="methodNAme">suspend(short type)</div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">close()</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h4 id="handlerbasedrophandler">HandlerBase::dropHandler</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">dropHandler()</div></div>
            <div class="classRow"><div class="classDesc">
            When a handler is finished processing events on a stream. It can call dropHandler() to remove itself from the event loop.<br>
            This is usually done automatically by higher level derived handlers.
            </div></div>
        </div>
    </div>
</div>
<h4 id="handlerbaseaddhandler">HandlerBase::addHandler</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">addHandler(Args&&... args)</div></div>
            <div class="classRow"><div class="classDesc">
            If the handler wants to create other handlers.<br>
            An example of this is when the SQL handlers are added. They create connections to the SQL server that require their own event handlers.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">args</div><div class="classValue">Arguments passed to the constructor of the new handler</div></div>
        </div>
    </div>
</div>
<h4 id="handlerbasemovehandler">HandlerBase::moveHandler</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">moveHandler(Args&&... args)</div></div>
            <div class="classRow"><div class="classDesc">
            This is similar to `addHandler()`.<br>
            The difference is that the current handler will immediately suspend until the created handler complets.<br>
            When the added handler calles `dropHandler()` control will be returned to the current handler at the point it suspended.<br>
            <br>
            Note: The current handler must be suspendable (otherwise an exception is thrown).
            See:  <a href="HandlerBase::suspendable">HandlerBase::suspendable</a>
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">args</div><div class="classValue">Arguments passed to the constructor of the new handler</div></div>
        </div>
    </div>
</div>
<h4 id="handlerbaseeventactivate">HandlerBase::eventActivate</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">eventActivate(LibSocketId sockId, short eventType)</div></div>
            <div class="classRow"><div class="classDesc">
            Method called when there is data on the socket.<br>
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value</div></div>
            <div class="classRow"><div class="classDesc">
            Return the type of event that you can next process on this stream: EV_READ or EV_WRITE or (EV_READ | EV_WITE)
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classItem">sockId</div><div class="classValue">The socket with data available on it.</div></div>
            <div class="classRow"><div class="classItem">eventType</div><div class="classValue">The type of event that caused this handler to be triggered (EV_READ | EV_WRITE)</div></div>
        </div>
    </div>
</div>
<h4 id="handlerbasesuspendable">HandlerBase::suspendable</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">suspendable()</div></div>
            <div class="classRow"><div class="classDesc">
            Return true if the handler is suspendable and false otherwise.<br>
            It is best to inherit from `HandlerNonSuspendable` or aHandlerNonSuspendable` rather than implement this yourself.
            </div></div>
        </div>
    </div>
</div>
<h4 id="handlerbasesuspend">HandlerBase::suspend</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">suspend(short type)</div></div>
            <div class="classRow"><div class="classDesc">
            Suspend the execution of this class until `type` (EV_READ | EV_WRITE) is available for this socket.<br>
            This basically returns control to the main event loop until data is available. This is used by the stream handlers to return control to the main event loop if they would block when reading from a stream.
            </div></div>
        </div>
    </div>
</div>
<h4 id="handlerbaseclose">HandlerBase::close</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">close()</div></div>
            <div class="classRow"><div class="classDesc">
            Close the stream associated with this handler.
            </div></div>
        </div>
    </div>
</div>
<h3 id="handlerstream">HandlerStream</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">HandlerStream</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerBase</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            This class is templatized based on the type of stream the socket represents.<br>
            The class basically defines a common class for holding the stream object and how to close it when requried.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerStream(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">void</div><div class="methodName">close()</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="handlernonsuspendable">HandlerNonSuspendable</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">HandlerNonSuspendable</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerStream</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            Defines `suspendable()` and `suspend()` for a class that is non suspendable.<br>
            This is used by some of ther server built in handlers that must complete. It is unlikely that this will be useful for a user defined handler.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerNonSuspendable(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div>bool<div class="methodName">suspendable()</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div>void<div class="methodName">suspend(short type)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="handlersuspendable">HandlerSuspendable</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">HandlerSuspendable</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerStream</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            Defines a handler that is suspendable.<br>
            Implements `suspendable`, `suspsend()` and `eventActivate()` as these all work together to define a class that can be suspended.<br>
            The method `eventActivateNonBlocking()` should be overwridden by derived classes to provide functionaliy.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerSuspendable(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div>bool<div class="methodName">suspendable()</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div>void<div class="methodName">suspend(short type)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet"></div>short<div class="methodName">eventActivate(LibSocketId sockId, short eventType)</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Virtual Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet">bool</div><div class="methodName">eventActivateNonBlocking()</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h4 id="handlersuspendableeventactivate">HandlerSuspendable::eventActivate</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">eventActivate(LibSocketId sockId, short eventType)</div></div>
            <div class="classRow"><div class="classDesc">
            On first call will start the method `eventActivateNonBlocking()`. This method may suspend itself by calling `suspend()`.<br>
            On subsequent calls will resume `eventActivateNonBlocking()` at the point where `suspend()` was called.<br>
            If `eventActivateNonBlocking()` returns true then `dropHandler()` is called to remove this handler as processing is complete.<br>
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value</div></div>
            <div class="classRow"><div class="classDesc">
            This method returns the type of socket event that should be listend for in the main event loop.
            </div></div>
        </div>
    </div>
</div>
<h4 id="handlerbaseeventactivatenonblocking">HandlerBase::eventActivateNonBlocking</h4>
<div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classSect">eventActivateNonBlocking()</div></div>
            <div class="classRow"><div class="classDesc">
            Called by eventActivate() to start processing of the stream.<br>
            If a blocking operation is about to be performed this method should call `suspend()` to return control to the main event loop.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value</div></div>
            Return true to cause the handler to be re-used.<br>
            Return false to not drop the handler. This is used if something clever is happening.
            <div class="classRow"><div class="classDesc">
            </div></div>
        </div>
    </div>
</div>
<h3 id="handlersuspendablewithstream">HandlerSuspendableWithStream</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/Handler.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">HandlerSuspendableWithStream</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerSuspendable</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            An implementation of `eventActivateNonBlocking()` that creates input and output stream objects.<br>
            These stream objects will call `suspend()` if they are about to perform a blocking operation on the underlying socket.<br>
            <br>
            Thus we have transparently non-blocking streams.
            </div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Public Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet"></div><div class="methodName">HandlerSuspendable(Server& parent, LibSocketId socketId, short eventType)</div><div class="methodMark"></div></div>
            <div class="classRow"><div class="methodRet">bool</div><div class="methodName">eventActivateNonBlocking()</div><div class="methodMark"></div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Virtual Members:</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="methodRet">bool</div><div class="methodName">eventActivateWithStream(std::istream& input, std::ostream& output)</div><div class="methodMark"></div></div>
        </div>
    </div>
</div>
<h3 id="serverhandler">ServerHandler</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/ServerHandlers.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">ServerHandler</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerNonSuspendable</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            An implementation of HandlerNonSuspendable that is used to accept connections and create other handlers.
            </div></div>
        </div>
    </div>
</div>
<h3 id="timerhandler">TimerHandler</h3>
<div class="classTable allowFloat">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorsNisseCoreService/ServerHandlers.h</div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Nisse::Core::Service</div></div>
            <div class="classRow"><div class="classItem">Class:    </div><div class="classValue">TimerHandler</div></div>
            <div class="classRow"><div class="classItem">Parent:   </div><div class="classValue">HandlerNonSuspendable</div></div>
        </div>
        <div class="classBlock">
            <div class="classRow"><div class="classDesc">
            An implementation of HandlerNonSuspendable that is used to implement the timer functionality.
            </div></div>
        </div>
    </div>
</div>
    
    
    
        
    <h3 id="handlerbase">HandlerBase</h3>
    
    

    <h3 id="handlerstream">HandlerStream</h3>
    
    

    <h3 id="handlernonsuspendable">HandlerNonSuspendable</h3>
    
    

    <h3 id="handlersuspendable">HandlerSuspendable</h3>
    
    

    <h3 id="handlersuspendablewithstream">HandlerSuspendableWithStream</h3>
    
    

    <h3 id="serverconnection">ServerConnection</h3>
    
    

    <h3 id="server">Server</h3>
    
    

    <h3 id="serverhandler">ServerHandler</h3>
    
    

    <h3 id="timerhandler">TimerHandler</h3>
    
    


    

    <h2 id="sql">SQL</h2>
    
    
                <pre><code class="cpp language-cpp">namespace Express = ThorsAnvil::Nisse::Protocol::HTTP;
namespace SQL     = ThorsAnvil::SQL;

static SQL::Connection connection("mysqlNB://test.com", "test", "testPassword", "test");
static SQL::Statement  listBeers(connection, "SELECT Name, Age FROM Beers");

class MyListBeerHandler: public HandlerSuspendable&lt;DataSocket&gt;
{
    virtual bool eventActivateNonBlocking()
    {
        ISocketStream   input(stream);

        std::string     request;
        std::getline(input, request);

        std::string     header;
        while(std::getline(input, header) &amp;&amp; header != "\r")
        {}

        std::stringsttream body;
        body &lt;&lt; "&lt;html&gt;"
             &lt;&lt; "&lt;head&gt;&lt;title&gt;Beer List&lt;/title&gt;&lt;/head&gt;"
             &lt;&lt; "&lt;body&gt;"
             &lt;&lt; "&lt;h1&gt;Beer List&lt;/h1&gt;"
             &lt;&lt; "&lt;ol&gt;";

        // Calling execute() suspends the current handler.
        // Control is returned (unsuspends the handler) when the execute() function returns.
        //
        // The execute function returns when all the rows have been returned from the SQL
        // DB. The lambda is executes once for each row that is ruturned this allowing us
        // to build the response as a stream.
        listBeers.execute([&amp;body](std::string const&amp; name, int age)
        {
            // This call to the MySQL server is also non blocking.
            // If the call is going to block control is returned to ThorNisse framework
            // Allowing another connection to be processed while the MySQL server finishes
            // Its work.
            body &lt;&lt; "&lt;li&gt;" &lt;&lt; name &lt;&lt; " : " &lt;&lt; age &lt;&lt; "&lt;/li&gt;";
        });
        body &lt;&lt; "&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt;";

        OSocketStream   output(stream);
        output &lt;&lt; "HTTP/1.1 200 OK\r\n"
                  "Content-Length: " &lt;&lt; body.size() &lt;&lt; "\r\n"
                  "\r\n"
                  &lt;&lt; body;
    }
};
</code></pre>
<pre><code class="cpp--DeepDive language-cpp--DeepDive">Please refer to the ThorSQL library for details.
</code></pre>
<p>A PIMPL proxy for the ThorSQL library.<br />
There are no user usable classes in this package. All the classes are used internally by ThorSQL library. There usage is unlocked by using the prefix "mysqlNB" in the connection string.</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Core::SQL</dd>
<dt>Headers:</dt><dd>ThorsNisseCoreSQL/</dd>
</dl>
    
    
    


    

    <h1 id="protocol">Protocol</h1>
    
    
        
    <h2 id="simple">Simple</h2>
    
    
                <p>A very simple protocol. These classes are used to test the functionality of Core::Service without the extra baggage of the HTTP protocol.</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Protocol::Simple</dd>
<dt>Headers:</dt><dd>ThorsNisseProtocolSimple/</dd>
</dl>
    
    
    

    <h2 id="http">HTTP</h2>
    
    
                <pre><code class="cpp--DeepDive language-cpp--DeepDive">class Site
{
    public:
        Site();
        Site(Site&amp;&amp;) noexcept;
        Site&amp; operator=(Site&amp;&amp;) noexcept;
        void swap(Site&amp;) noexcept;

        void get(std::string&amp;&amp; path, Action&amp;&amp; action)    {add(Method::Get,    std::move(path), std::move(action));}
        void put(std::string&amp;&amp; path, Action&amp;&amp; action)    {add(Method::Put,    std::move(path), std::move(action));}
        void del(std::string&amp;&amp; path, Action&amp;&amp; action)    {add(Method::Delete, std::move(path), std::move(action));}
        void post(std::string&amp;&amp; path, Action&amp;&amp; action)   {add(Method::Post,   std::move(path), std::move(action));}
        void all(std::string&amp;&amp; path, Action&amp;&amp; action)    {add(4,              std::move(path), std::move(action));}
        std::pair&lt;bool, Action&gt; find(Method method, std::string const&amp; path) const;
};

class Binder
{
    public:
        Binder();
        void setCustome404Action(Action&amp;&amp; action);
        void addSite(std::string const&amp; host, std::string const&amp; base, Site&amp;&amp; site);
        std::pair&lt;bool, int&gt; remSite(std::string const&amp; host, std::string const&amp; base);

        Action find(Method method, std::string const&amp; host, std::string const&amp; path) const;
};

class DeveloperHandler: public Core::Service::HandlerNonSuspendable&lt;Core::Socket::DataSocket&gt;
{
    public:
        DeveloperHandler(Core::Service::Server&amp; parent, Core::Socket::DataSocket&amp;&amp; socket, DynamicSiteLoader&amp; loader);
        virtual short eventActivate(Core::Service::LibSocketId sockId, short eventType) override;
};

class DynamicSiteLoader
{
    public:
        DynamicSiteLoader(Core::Service::Server&amp; server);
        std::tuple&lt;bool, int&gt;      load(std::string const&amp; site, int port, std::string const&amp; host, std::string const&amp; base);
        std::tuple&lt;bool, int, int&gt; unload(int port, std::string const&amp; host, std::string const&amp; base);
        void                       setMaxWaitingConnections(int max);
};

class ReadRequestHandler: public Core::Service::HandlerSuspendable&lt;Core::Socket::DataSocket&gt;
{
    public:
        ReadRequestHandler(Core::Service::Server&amp; parent, Core::Socket::DataSocket&amp;&amp; socket, Binder const&amp; binder);
        virtual bool eventActivateNonBlocking() override;
        void setFlusher(Response* f){flusher = f;}
        void flushing()             {if (flusher){flusher-&gt;flushing();}}
};

struct HttpParserData
{
    HttpParserData();
    void addCurrentHeader();

        Headers                 headers;
        std::string             currentHead;
        std::string             currentValue;
        std::string             uri;
        char const*             bodyBegin;
        char const*             bodyEnd;
        Method                  method;
        bool                    messageComplete;
        bool                    gotValue;
};

class HttpScanner
{
    public:
        HttpParserData          data;

        HttpScanner();
        void scan(char const* buffer, std::size_t size);
};

class Route
{
    public:
        Route(std::string&amp;&amp; fullRoute);
        Route(Route const&amp;)            = delete;
        Route&amp; operator=(Route const&amp;) = delete;
        Route(Route&amp;&amp;) = default;

        bool operator&lt;(Route const&amp; rhs) const;
        bool operator&lt;(std::string const&amp; rhs) const;
        bool operator&lt;=(std::string const&amp; rhs) const;
        bool operator==(std::string const&amp; rhs) const;
};

struct RouteTester
{
    using is_transparent = std::true_type;

    bool operator()(std::string const&amp; lhs, Route const&amp; rhs) const {return !(rhs &lt;= lhs);}
    bool operator()(Route const&amp; lhs, std::string const&amp; rhs) const {return lhs &lt; rhs;}
    bool operator()(Route const&amp; lhs, Route const&amp; rhs)       const {return lhs &lt; rhs;}
};

class Headers
{
    public:
        typedef ConstIterator const_iterator;
        class Inserter
        {
            ValueStore&amp;  valueStore;
            public:
                Inserter(ValueStore&amp; valueStore);
                void operator=(std::string&amp;&amp; value);
                void operator=(std::string const&amp; value);
        };

        ConstIterator begin() const {return std::cbegin(data);}
        ConstIterator end()   const {return std::cend(data);}
        Inserter operator[](std::string const&amp; key)    {return data[key];}

        std::size_t        getVersions(std::string const&amp; key) const;
        std::string const&amp; get(std::string const&amp; key, std::size_t version = 0) const;
};

class URI
{
    public:
        std::string original;
        std::string normalized;

        std::string schema;
        std::string host;
        std::string path;
        std::string query;
        std::string fragment;
        short       port;

        Headers     queryParam;

        URI(std::string const&amp; hostAndPort, std::string&amp;&amp; pathAndQuery);
};

class Request
{
    public:
        const Method            method;
        const URI               uri;
        const Headers&amp;          headers;
        std::istream&amp;           body;

        Request(Method method,
                URI&amp;&amp; uri,
                Headers&amp; headers,
                std::istream&amp; body);
};

class Response
{
    public:
        short                   resultCode;
        std::string             resultMessage;
        Headers                 headers;
        std::ostream&amp;           body;

        Response(std::ostream&amp; body);
        Response(ReadRequestHandler&amp; flusher,
                 DataSocket&amp; socket,
                 std::ostream&amp; body,
                 short resultCode = 200,
                 std::string const&amp; resultMessage = "OK");
        ~Response();
        void flushing(bool allDone = false);
};
</code></pre>
<p>An implementation of the HTTP protocol</p>
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Nisse::Protocol::HTTP</dd>
<dt>Headers:</dt><dd>ThorsNisseProtocolHTTP/</dd>
<dt>Binder.h</dt><dd>

* class Site
* class Binder

</dd>
<dt>DeveloperHandler.h</dt><dd>

* class DeveloperHandler: public Core::Service::HandlerNonSuspendable

</dd>
<dt>DynamicSiteLoader.h</dt><dd>

* class DynamicSiteLoader

</dd>
<dt>HTTPProtocol.h</dt><dd>

* class ReadRequestHandler: public Core::Service::HandlerSuspendable

</dd>
<dt>HttpScanner.h</dt><dd>

* struct HttpParserData
* class HttpScanner

</dd>
<dt>Route.h</dt><dd>

* class Route
* struct RouteTester

</dd>
<dt>Types.h</dt><dd>

* class Headers
* class URI
* class Request
* class Response

</dd>
</dl>
    
    
    


    

    <h1 id="examples">Examples</h1>
    
    
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</p>
<h2 id="addbeer">AddBeer</h2>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</p>
    
    
    
        
    <h2 id="addbeer">AddBeer</h2>
    
    


    


    </div>
    <div class="dark-box"></div>
</div>

</body>


</html>
